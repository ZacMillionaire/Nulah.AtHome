@using Nulah.AtHome.Api.Services
@using Nulah.AtHome.Data.DTO.Events
@*
without this the view will be rendered twice, once on the server that gets sent to the user and then again once it completes
or something.

With this it'll stop double calls to load events in this instance

this link has a more complicated solution as well
https://jonhilton.net/persist-state-between-renders-net8/

need to look up blazor prerender on the server avoid double load
*@
@rendermode @(new InteractiveServerRenderMode(false))
<h3>Events</h3>
@if (_isLoading)
{
    // In the future this will simply disable the list to account for existing items already being available
    // which means dragging the loop below up and making sure it doesn't throw a null reference exception on event service
    <h2>Loading...</h2>
}

@foreach (var eventDto in Events)
{
    <EventItem EventDto="@eventDto"/>
}

@code {

    [Inject]
    private EventService EventService { get; set; }

    private List<BasicEventDto> Events { get; set; } = new();

    private bool _isLoading = true;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
            return;

        ArgumentNullException.ThrowIfNull(EventService);
        EventService.EventsUpdated += OnChanged;

        await EventService.LoadEvents();
        // _isLoading = false;
        // triggers the component to rerender
        await InvokeAsync(StateHasChanged);
    }

    private void OnChanged(object? sender, List<BasicEventDto> e)
    {
        // Update is loading if it was previously changed to true elsewhere, eg, a hard refresh button was clicked
        if (_isLoading)
        {
            _isLoading = false;
        }

        Events = e;

        InvokeAsync(StateHasChanged);
    }

    // Don't really know what part of the blazor lifecycle this would be called
    public void Dispose()
    {
        EventService.EventsUpdated -= this.OnChanged;
    }

}